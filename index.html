<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Collatz Voxel Terrain</title>
    <style>
        :root {
            --primary: #667eea;
            --primary-dark: #5a67d8;
            --secondary: #764ba2;
            --accent: #f093fb;
            --success: #48bb78;
            --warning: #ed8936;
            --error: #f56565;
            --bg-primary: #0a0a0f;
            --bg-secondary: rgba(255, 255, 255, 0.08);
            --bg-tertiary: rgba(255, 255, 255, 0.04);
            --border: rgba(255, 255, 255, 0.12);
            --text-primary: #f7fafc;
            --text-secondary: #cbd5e0;
            --text-muted: #a0aec0;
            --shadow: rgba(0, 0, 0, 0.25);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, #1a1a2e 100%);
            color: var(--text-primary);
            overflow: hidden;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #renderer {
            display: block;
        }

        /* Enhanced UI Overlay System */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 1000;
            transition: opacity 0.3s ease;
        }

        /* Modern HUD with better animations */
        .game-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid var(--border);
            box-shadow: 0 8px 32px var(--shadow);
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translateY(0);
        }

        .game-hud:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px var(--shadow);
        }

        .hud-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .hud-item:last-child {
            margin-bottom: 0;
        }

        .hud-item strong {
            color: var(--text-primary);
            margin-right: 12px;
        }

        .hud-value {
            color: var(--primary);
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        /* Enhanced Controls Panel */
        .controls-panel {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 24px;
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid var(--border);
            box-shadow: 0 8px 32px var(--shadow);
            pointer-events: all;
            max-width: 380px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .control-group {
            margin-bottom: 24px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group h3 {
            margin: 0 0 16px 0;
            font-size: 1.1em;
            color: var(--text-primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-row {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        label {
            min-width: 80px;
            font-size: 0.9em;
            font-weight: 500;
            color: var(--text-secondary);
        }

        /* Enhanced Form Controls */
        input[type="number"], input[type="range"], select {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            color: var(--text-primary);
            padding: 10px 14px;
            border-radius: 10px;
            flex: 1;
            min-width: 80px;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }

        input[type="range"] {
            padding: 0;
            height: 32px;
            background: transparent;
            -webkit-appearance: none;
            appearance: none;
        }

        /* Custom Range Slider */
        input[type="range"]::-webkit-slider-track {
            background: var(--bg-tertiary);
            height: 6px;
            border-radius: 3px;
            border: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .range-value {
            min-width: 50px;
            text-align: center;
            font-size: 0.9em;
            font-weight: bold;
            color: var(--primary);
            background: var(--bg-tertiary);
            padding: 4px 8px;
            border-radius: 6px;
        }

        /* Enhanced Buttons */
        button {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9em;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        button:hover::before {
            left: 100%;
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            color: var(--text-primary);
        }

        button.secondary:hover {
            background: var(--bg-secondary);
            border-color: var(--primary);
            box-shadow: 0 8px 25px rgba(255, 255, 255, 0.1);
        }

        /* Enhanced Texture Pack Selector */
        .texture-pack-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }

        .texture-pack-option {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .texture-pack-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .texture-pack-option.active {
            border-color: var(--primary);
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .texture-pack-option.active::before {
            opacity: 0.1;
        }

        .texture-pack-preview {
            width: 100%;
            height: 60px;
            border-radius: 8px;
            margin-bottom: 8px;
            background: linear-gradient(45deg, #4a5568, #2d3748);
            position: relative;
            overflow: hidden;
        }

        .texture-pack-name {
            font-size: 0.8em;
            font-weight: 600;
            color: var(--text-primary);
            position: relative;
            z-index: 1;
        }

        /* Enhanced Status Indicator */
        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-radius: 50px;
            font-size: 0.85em;
            border: 1px solid var(--border);
            backdrop-filter: blur(20px) saturate(180%);
            pointer-events: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px var(--shadow);
        }

        .status-indicator.locked {
            color: var(--success);
            border-color: var(--success);
            box-shadow: 0 4px 16px rgba(72, 187, 120, 0.2);
        }

        .status-indicator.unlocked {
            color: var(--warning);
            border-color: var(--warning);
            box-shadow: 0 4px 16px rgba(237, 137, 54, 0.2);
        }

        /* Enhanced Controls Help */
        .controls-help {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 16px 20px;
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid var(--border);
            pointer-events: none;
            font-size: 0.85em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px var(--shadow);
            line-height: 1.6;
        }

        .controls-help strong {
            color: var(--primary);
        }

        /* Enhanced Crosshair */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            pointer-events: none;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.6);
        }

        .crosshair::before {
            top: 50%;
            left: 2px;
            right: 2px;
            height: 2px;
            transform: translateY(-50%);
        }

        .crosshair::after {
            left: 50%;
            top: 2px;
            bottom: 2px;
            width: 2px;
            transform: translateX(-50%);
        }

        /* Enhanced Modal Overlays */
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px) saturate(180%);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
        }

        .modal-content {
            background: var(--bg-secondary);
            border-radius: 24px;
            padding: 32px;
            border: 1px solid var(--border);
            backdrop-filter: blur(20px) saturate(180%);
            box-shadow: 0 20px 60px var(--shadow);
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            transform: scale(0.9) translateY(20px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .modal-overlay.active .modal-content {
            transform: scale(1) translateY(0);
        }

        /* Performance Overlay */
        .performance-overlay {
            position: absolute;
            top: 80px;
            right: 20px;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 12px 16px;
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid var(--border);
            pointer-events: none;
            font-size: 0.8em;
            box-shadow: 0 4px 16px var(--shadow);
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }

        .performance-overlay.visible {
            opacity: 1;
            transform: translateX(0);
        }

        .perf-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            gap: 16px;
        }

        .perf-item:last-child {
            margin-bottom: 0;
        }

        .perf-value {
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .perf-good { color: var(--success); }
        .perf-warning { color: var(--warning); }
        .perf-error { color: var(--error); }

        /* Loading with better animations */
        .loading-overlay {
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
        }

        .loading-content {
            text-align: center;
            color: var(--text-primary);
        }

        .loading-title {
            font-size: 1.4em;
            margin-bottom: 12px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
        }

        .progress-container {
            width: 400px;
            margin: 20px auto;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .game-hud, .controls-help {
                left: 10px;
                right: 10px;
                max-width: none;
            }
            
            .status-indicator {
                right: 10px;
            }
            
            .controls-panel {
                max-width: none;
            }
            
            .texture-pack-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-dark);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="renderer"></canvas>
        
        <div class="ui-overlay">
            <!-- Enhanced Game HUD -->
            <div class="game-hud" id="gameHud">
                <div class="hud-item">
                    <strong>🚀 FPS:</strong>
                    <span class="hud-value" id="fpsCounter">-</span>
                </div>
                <div class="hud-item">
                    <strong>🧱 Blocks:</strong>
                    <span class="hud-value" id="blockCount">-</span>
                </div>
                <div class="hud-item">
                    <strong>🔗 Meshes:</strong>
                    <span class="hud-value" id="meshCount">-</span>
                </div>
                <div class="hud-item">
                    <strong>🎲 Seed:</strong>
                    <span class="hud-value" id="currentSeed">27</span>
                </div>
                <div class="hud-item">
                    <strong>🎨 Pack:</strong>
                    <span class="hud-value" id="currentTexturePack">Classic</span>
                </div>
            </div>

            <!-- Performance Overlay (toggleable) -->
            <div class="performance-overlay" id="performanceOverlay">
                <div class="perf-item">
                    <span>Draw Calls:</span>
                    <span class="perf-value" id="drawCalls">-</span>
                </div>
                <div class="perf-item">
                    <span>Triangles:</span>
                    <span class="perf-value" id="triangles">-</span>
                </div>
                <div class="perf-item">
                    <span>Memory:</span>
                    <span class="perf-value" id="memory">-</span>
                </div>
            </div>

            <!-- Enhanced Status indicator -->
            <div class="status-indicator unlocked" id="statusIndicator">
                🖱️ Click to enable mouse look
            </div>

            <!-- Enhanced Controls help -->
            <div class="controls-help">
                <strong>🎮 Controls:</strong><br>
                <strong>WASD</strong> Move • <strong>Mouse</strong> Look • <strong>Shift</strong> Run • <strong>Space</strong> Jump<br>
                <strong>ESC</strong> Menu • <strong>M</strong> Map • <strong>P</strong> Performance • <strong>T</strong> Textures
            </div>

            <!-- Crosshair -->
            <div class="crosshair"></div>
        </div>

        <!-- Enhanced Pause Menu -->
        <div class="modal-overlay" id="pauseOverlay">
            <div class="modal-content" style="max-width: 1000px;">
                <div style="text-align: center; margin-bottom: 30px;">
                    <h1 style="font-size: 2.5em; background: linear-gradient(135deg, var(--primary), var(--secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 10px;">
                        ⛰️ Collatz Voxel Terrain
                    </h1>
                    <p style="color: var(--text-secondary); font-size: 1.1em;">Mathematical landscapes in infinite detail</p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px;">
                    <!-- Enhanced Controls -->
                    <div class="controls-panel">
                        <div class="control-group">
                            <h3>🎲 Generation</h3>
                            <div class="control-row">
                                <input type="number" id="seed" value="27" min="1" max="999999" placeholder="Seed">
                                <button onclick="generateTerrain()">Generate</button>
                            </div>
                            <div class="control-row">
                                <button onclick="randomSeed()">🎰 Random</button>
                                <button class="secondary" onclick="toggleAnimation()" id="animateBtn">▶️ Animate</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <h3>🏔️ Terrain</h3>
                            <div class="control-row">
                                <label>Scale:</label>
                                <input type="range" id="scale" min="1" max="20" step="0.5" value="8">
                                <span class="range-value" id="scaleValue">8</span>
                            </div>
                            <div class="control-row">
                                <label>Height:</label>
                                <input type="range" id="height" min="5" max="50" value="20">
                                <span class="range-value" id="heightValue">20</span>
                            </div>
                            <div class="control-row">
                                <label>Size:</label>
                                <select id="worldSize">
                                    <option value="32">Small (32x32)</option>
                                    <option value="64" selected>Medium (64x64)</option>
                                    <option value="96">Large (96x96)</option>
                                    <option value="128">Huge (128x128)</option>
                                </select>
                            </div>
                        </div>

                        <div class="control-group">
                            <h3>🎮 Movement</h3>
                            <div class="control-row">
                                <label>Speed:</label>
                                <input type="range" id="moveSpeed" min="10" max="200" value="100">
                                <span class="range-value" id="speedValue">100</span>
                            </div>
                            <div class="control-row">
                                <label>Mouse:</label>
                                <input type="range" id="mouseSensitivity" min="1" max="10" step="0.1" value="3">
                                <span class="range-value" id="sensitivityValue">3</span>
                            </div>
                        </div>

                        <div class="control-group">
                            <h3>🎨 Visual Style</h3>
                            <div class="texture-pack-grid" id="texturePackSelector"></div>
                        </div>
                    </div>

                    <!-- Enhanced Info Panel -->
                    <div class="controls-panel">
                        <div class="control-group">
                            <h3>📊 Statistics</h3>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 0.8em; color: var(--text-secondary); margin-bottom: 4px;">Sequence Length</div>
                                    <div style="font-size: 1.4em; color: var(--primary); font-weight: bold;" id="sequenceLength">-</div>
                                </div>
                                <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 0.8em; color: var(--text-secondary); margin-bottom: 4px;">Max Value</div>
                                    <div style="font-size: 1.4em; color: var(--secondary); font-weight: bold;" id="maxValue">-</div>
                                </div>
                                <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 0.8em; color: var(--text-secondary); margin-bottom: 4px;">Total Blocks</div>
                                    <div style="font-size: 1.4em; color: var(--accent); font-weight: bold;" id="blockCountPause">-</div>
                                </div>
                                <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 0.8em; color: var(--text-secondary); margin-bottom: 4px;">World Size</div>
                                    <div style="font-size: 1.4em; color: var(--success); font-weight: bold;" id="worldSizeStat">64x64</div>
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <h3>🔢 Sequence Preview</h3>
                            <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 12px; font-family: 'Courier New', monospace; font-size: 0.85em; line-height: 1.6; max-height: 80px; overflow-y: auto;" id="sequenceMini">
                                Generating sequence...
                            </div>
                        </div>

                        <div class="control-group">
                            <h3>⚡ Quick Actions</h3>
                            <div class="control-row">
                                <button onclick="toggleFullscreen()">🔳 Fullscreen</button>
                                <button class="secondary" onclick="resetCamera()">📍 Reset View</button>
                            </div>
                            <div class="control-row">
                                <button class="secondary" onclick="togglePerformanceOverlay()">📊 Performance</button>
                                <button class="secondary" onclick="exportScreenshot()">📸 Screenshot</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="text-align: center; padding-top: 20px; border-top: 1px solid var(--border);">
                    <button style="font-size: 1.2em; padding: 16px 32px; background: linear-gradient(135deg, var(--success), #48bb78);" onclick="resumeGame()">
                        ▶️ Resume Game
                    </button>
                    <p style="margin-top: 12px; color: var(--text-muted);">Press ESC to resume</p>
                </div>
            </div>
        </div>

        <!-- Map Modal Overlay -->
        <div class="modal-overlay" id="mapOverlay">
            <div class="modal-content" style="max-width: 800px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border);">
                    <h2 style="margin: 0; background: linear-gradient(135deg, var(--primary), var(--secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-size: 1.5em;">
                        🗺️ Terrain Map
                    </h2>
                    <button style="background: none; border: none; color: var(--text-primary); font-size: 1.5em; cursor: pointer; padding: 5px 10px; border-radius: 5px; transition: background 0.2s;" onclick="toggleMap()">✕</button>
                </div>
                
                <div style="display: flex; gap: 20px; margin-bottom: 20px; align-items: flex-start;">
                    <div style="position: relative;">
                        <canvas id="mapCanvas" width="400" height="400" style="border: 2px solid var(--border); border-radius: 10px; background: #000000; cursor: crosshair; width: 400px; height: 400px; flex-shrink: 0;" onclick="onMapClick(event)"></canvas>
                        <div style="position: absolute; top: 8px; left: 8px; background: rgba(0, 0, 0, 0.8); color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8em;" id="mapCoords">X: 0, Z: 0</div>
                    </div>
                    
                    <div style="flex: 1; display: flex; flex-direction: column; gap: 12px;">
                        <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 8px; border: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
                            <span style="font-size: 0.9em; color: var(--text-secondary);">Position:</span>
                            <span style="font-weight: bold; color: var(--primary);" id="playerPosition">X: 32, Z: 32</span>
                        </div>
                        <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 8px; border: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
                            <span style="font-size: 0.9em; color: var(--text-secondary);">Elevation:</span>
                            <span style="font-weight: bold; color: var(--secondary);" id="playerElevation">Y: 25</span>
                        </div>
                        <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 8px; border: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
                            <span style="font-size: 0.9em; color: var(--text-secondary);">Biome:</span>
                            <span style="font-weight: bold; color: var(--accent);" id="playerBiome">Grassland</span>
                        </div>
                        
                        <!-- Interactive Features -->
                        <div style="background: linear-gradient(135deg, var(--primary), var(--secondary)); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                            <div style="font-weight: bold; margin-bottom: 8px; font-size: 0.9em;">🎯 Map Activities</div>
                            <div style="font-size: 0.8em; line-height: 1.4; opacity: 0.9;">
                                <strong>Click</strong> to place waypoints<br>
                                <strong>🏆 Treasures:</strong> <span id="treasureCount">0</span>/5<br>
                                <strong>📍 Waypoints:</strong> <span id="waypointCount">0</span><br>
                                <strong>🔍 Discoveries:</strong> <span id="discoveryCount">0</span>/3
                            </div>
                        </div>
                        
                        <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 8px; border: 1px solid var(--border); text-align: center;">
                            <button class="secondary" onclick="clearWaypoints()" style="margin-right: 8px; font-size: 0.8em; padding: 6px 12px;">Clear Waypoints</button>
                            <button class="secondary" onclick="teleportToWaypoint()" style="font-size: 0.8em; padding: 6px 12px;">Go to Waypoint</button>
                        </div>
                        
                        <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 8px; border: 1px solid var(--border); text-align: center; margin-top: 10px;">
                            <button class="secondary" onclick="toggleMap()">Close Map (M)</button>
                        </div>
                    </div>
                </div>
                
                <div style="border-top: 1px solid var(--border); padding-top: 15px;">
                    <div style="font-weight: bold; margin-bottom: 10px; font-size: 1.1em; color: var(--text-primary);">Map Legend</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px;" id="mapLegend"></div>
                </div>
            </div>
        </div>

        <!-- Loading Overlay -->
        <div class="modal-overlay loading-overlay" id="loadingOverlay">
            <div class="loading-content">
                <div class="loading-title">🎲 Generating Mathematical Terrain</div>
                <div style="color: var(--text-secondary); margin-bottom: 20px;">Creating your voxel world with enhanced materials...</div>
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressBar"></div>
                    </div>
                </div>
                <div style="font-size: 0.9em; color: var(--text-muted); margin-top: 12px;" id="loadingStatus">Initializing...</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============ ENHANCED CONFIGURATION ============
        const CONFIG = {
            WORLD: {
                BLOCK_SIZE: 1,
                DEFAULT_SIZE: 64,
                MAX_HEIGHT: 50,
                WATER_LEVEL: 0.3,
                INSTANCING_THRESHOLD: 50
            },
            PLAYER: {
                HEIGHT: 1.8,
                BASE_SPEED: 100,
                RUN_MULTIPLIER: 2,
                JUMP_POWER: 12,
                BASE_MOUSE_SENSITIVITY: 0.003,
                GRAVITY: 25,
                FRICTION: 0.85,
                COLLISION_RADIUS: 0.4
            },
            RENDERING: {
                FOV: 75,
                NEAR: 0.1,
                FAR: 1000,
                FOG_NEAR: 150,
                FOG_FAR: 300,
                MAX_PIXEL_RATIO: 2,
                SHADOW_MAP_SIZE: 2048
            },
            MATERIALS: {
                ENABLE_TEXTURES: true,
                ENABLE_NORMAL_MAPS: true,
                ENABLE_ROUGHNESS: true,
                TEXTURE_REPEAT: 1,
                NORMAL_SCALE: 0.5
            }
        };

        // ============ ENHANCED TEXTURE PACKS ============
        const TEXTURE_PACKS = {
            classic: {
                name: "Classic",
                description: "Clean, colorful blocks",
                materials: {
                    water: { color: 0x1a5490, roughness: 0.1, metalness: 0.8 },
                    sand: { color: 0xf5deb3, roughness: 0.9, metalness: 0.0 },
                    grass: { color: 0x3e7b3e, roughness: 0.8, metalness: 0.0 },
                    stone: { color: 0x8b7355, roughness: 0.7, metalness: 0.1 },
                    snow: { color: 0xffffff, roughness: 0.3, metalness: 0.0 }
                }
            },
            realistic: {
                name: "Realistic",
                description: "Natural textures with depth",
                materials: {
                    water: { color: 0x1a5490, roughness: 0.05, metalness: 0.9, transparent: true, opacity: 0.8 },
                    sand: { color: 0xd2b48c, roughness: 0.95, metalness: 0.0 },
                    grass: { color: 0x228b22, roughness: 0.9, metalness: 0.0 },
                    stone: { color: 0x696969, roughness: 0.8, metalness: 0.2 },
                    snow: { color: 0xf8f8ff, roughness: 0.2, metalness: 0.0 }
                }
            },
            volcanic: {
                name: "Volcanic",
                description: "Molten and metallic surfaces",
                materials: {
                    lava: { color: 0xff4500, roughness: 0.3, metalness: 0.7, emissive: 0x330000 },
                    obsidian: { color: 0x2f2f2f, roughness: 0.1, metalness: 0.9 },
                    ash: { color: 0x696969, roughness: 0.95, metalness: 0.0 },
                    basalt: { color: 0x404040, roughness: 0.6, metalness: 0.3 },
                    sulfur: { color: 0xffff00, roughness: 0.8, metalness: 0.1, emissive: 0x111100 }
                }
            },
            neon: {
                name: "Neon",
                description: "Glowing cyberpunk blocks",
                materials: {
                    void: { color: 0x000033, roughness: 0.1, metalness: 0.9, emissive: 0x000011 },
                    electric: { color: 0x0066ff, roughness: 0.2, metalness: 0.8, emissive: 0x001133 },
                    magenta: { color: 0xff00ff, roughness: 0.3, metalness: 0.7, emissive: 0x330033 },
                    lime: { color: 0x00ff00, roughness: 0.4, metalness: 0.6, emissive: 0x003300 },
                    cyber: { color: 0xffffff, roughness: 0.1, metalness: 1.0, emissive: 0x111111 }
                }
            },
            crystal: {
                name: "Crystal",
                description: "Transparent gemstone materials",
                materials: {
                    sapphire: { color: 0x0066cc, roughness: 0.0, metalness: 0.0, transparent: true, opacity: 0.7 },
                    emerald: { color: 0x00cc66, roughness: 0.1, metalness: 0.0, transparent: true, opacity: 0.8 },
                    ruby: { color: 0xcc0066, roughness: 0.05, metalness: 0.0, transparent: true, opacity: 0.75 },
                    diamond: { color: 0xffffff, roughness: 0.0, metalness: 0.0, transparent: true, opacity: 0.9 },
                    amethyst: { color: 0x9966cc, roughness: 0.02, metalness: 0.0, transparent: true, opacity: 0.8 }
                }
            }
        };

        // ============ GLOBAL STATE ============
        let state = {
            scene: null,
            camera: null,
            renderer: null,
            controls: {
                forward: false,
                backward: false,
                left: false,
                right: false,
                jump: false,
                run: false
            },
            player: {
                position: new THREE.Vector3(32, 30, 32),
                velocity: new THREE.Vector3(0, 0, 0),
                yaw: 0,
                pitch: 0,
                onGround: false,
                speed: CONFIG.PLAYER.BASE_SPEED,
                mouseSensitivity: CONFIG.PLAYER.BASE_MOUSE_SENSITIVITY
            },
            world: {
                blocks: new Map(),
                terrainData: null,
                size: 64,
                maxHeight: 20
            },
            mapFeatures: {
                waypoints: [],
                treasures: [],
                discoveries: [],
                selectedWaypoint: null
            },
            achievements: {
                treasuresFound: 0,
                waypointsPlaced: 0,
                distanceTraveled: 0,
                discoveries: new Set()
            },
            currentTexturePack: 'classic',
            sequence: [],
            maxValue: 0,
            animationFrame: null,
            isPointerLocked: false,
            isPaused: false,
            isMapOpen: false,
            performanceVisible: false,
            fpsCounter: 0,
            lastTime: 0,
            frameCount: 0,
            lastFpsUpdate: 0,
            renderStats: {
                drawCalls: 0,
                triangles: 0,
                memory: 0
            }
        };

        // ============ ENHANCED MATERIAL SYSTEM ============
        const materialCache = new Map();

        /**
         * Creates enhanced materials with proper PBR properties
         * @param {string} materialType - Type of material from texture pack
         * @param {Object} packData - Material data from current texture pack
         * @returns {THREE.Material} Enhanced Three.js material
         */
        function createEnhancedMaterial(materialType, packData) {
            const cacheKey = `${state.currentTexturePack}_${materialType}`;
            
            if (materialCache.has(cacheKey)) {
                return materialCache.get(cacheKey);
            }

            if (!packData) {
                console.warn(`Material type '${materialType}' not found in texture pack '${state.currentTexturePack}'`);
                packData = { color: 0x888888, roughness: 0.8, metalness: 0.2 };
            }

            // Create PBR material with enhanced properties
            const material = new THREE.MeshStandardMaterial({
                color: packData.color || 0x888888,
                roughness: packData.roughness || 0.8,
                metalness: packData.metalness || 0.2,
                transparent: packData.transparent || false,
                opacity: packData.opacity || 1.0,
                emissive: packData.emissive || 0x000000,
                side: THREE.FrontSide,
                // Performance optimizations
                alphaToCoverage: false,
                alphaTest: packData.transparent ? 0.1 : 0,
                depthWrite: !packData.transparent,
                flatShading: false
            });

            // Add procedural texture patterns for more detail
            if (CONFIG.MATERIALS.ENABLE_TEXTURES) {
                const textureSize = 64;
                const canvas = createProceduralTexture(materialType, textureSize);
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(CONFIG.MATERIALS.TEXTURE_REPEAT, CONFIG.MATERIALS.TEXTURE_REPEAT);
                
                // Apply subtle texture overlay
                material.map = texture;
                
                // Create normal map for surface detail
                if (CONFIG.MATERIALS.ENABLE_NORMAL_MAPS) {
                    const normalCanvas = createNormalMap(materialType, textureSize);
                    const normalTexture = new THREE.CanvasTexture(normalCanvas);
                    normalTexture.wrapS = THREE.RepeatWrapping;
                    normalTexture.wrapT = THREE.RepeatWrapping;
                    normalTexture.repeat.set(CONFIG.MATERIALS.TEXTURE_REPEAT, CONFIG.MATERIALS.TEXTURE_REPEAT);
                    
                    material.normalMap = normalTexture;
                    material.normalScale = new THREE.Vector2(CONFIG.MATERIALS.NORMAL_SCALE, CONFIG.MATERIALS.NORMAL_SCALE);
                }
            }

            materialCache.set(cacheKey, material);
            return material;
        }

        /**
         * Creates procedural textures for materials
         * @param {string} materialType - Type of material
         * @param {number} size - Texture size in pixels
         * @returns {HTMLCanvasElement} Generated texture canvas
         */
        function createProceduralTexture(materialType, size) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Base color from material
            const packData = TEXTURE_PACKS[state.currentTexturePack];
            const materials = Object.values(packData.materials);
            const baseMaterial = materials[0] || { color: 0x888888 };
            
            const baseColor = `#${baseMaterial.color.toString(16).padStart(6, '0')}`;
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, size, size);

            // Add procedural patterns based on material type
            switch (materialType) {
                case 'stone':
                case 'basalt':
                    addStonePattern(ctx, size);
                    break;
                case 'grass':
                    addGrassPattern(ctx, size);
                    break;
                case 'sand':
                    addSandPattern(ctx, size);
                    break;
                case 'water':
                case 'lava':
                    addFluidPattern(ctx, size);
                    break;
                default:
                    addGenericPattern(ctx, size);
            }

            return canvas;
        }

        /**
         * Creates normal maps for enhanced surface detail
         * @param {string} materialType - Type of material
         * @param {number} size - Texture size in pixels
         * @returns {HTMLCanvasElement} Generated normal map canvas
         */
        function createNormalMap(materialType, size) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Generate height map first
            const heightData = new Array(size * size);
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const noise = Math.random() * 0.5 + 0.5;
                    heightData[y * size + x] = noise;
                }
            }

            // Convert height map to normal map
            const imageData = ctx.createImageData(size, size);
            const data = imageData.data;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const index = (y * size + x) * 4;
                    
                    // Sample neighboring heights
                    const tl = heightData[((y - 1 + size) % size) * size + ((x - 1 + size) % size)];
                    const tm = heightData[((y - 1 + size) % size) * size + x];
                    const tr = heightData[((y - 1 + size) % size) * size + ((x + 1) % size)];
                    const ml = heightData[y * size + ((x - 1 + size) % size)];
                    const mr = heightData[y * size + ((x + 1) % size)];
                    const bl = heightData[((y + 1) % size) * size + ((x - 1 + size) % size)];
                    const bm = heightData[((y + 1) % size) * size + x];
                    const br = heightData[((y + 1) % size) * size + ((x + 1) % size)];

                    // Calculate gradients
                    const dx = (tr + 2 * mr + br) - (tl + 2 * ml + bl);
                    const dy = (bl + 2 * bm + br) - (tl + 2 * tm + tr);

                    // Convert to normal vector
                    const length = Math.sqrt(dx * dx + dy * dy + 1);
                    const nx = (dx / length) * 0.5 + 0.5;
                    const ny = (dy / length) * 0.5 + 0.5;
                    const nz = (1 / length) * 0.5 + 0.5;

                    data[index] = Math.floor(nx * 255);     // Red
                    data[index + 1] = Math.floor(ny * 255); // Green
                    data[index + 2] = Math.floor(nz * 255); // Blue
                    data[index + 3] = 255;                  // Alpha
                }
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // Procedural pattern functions
        function addStonePattern(ctx, size) {
            ctx.globalAlpha = 0.3;
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const radius = Math.random() * 3 + 1;
                ctx.fillStyle = `rgba(${Math.random() * 50}, ${Math.random() * 50}, ${Math.random() * 50}, 0.5)`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        function addGrassPattern(ctx, size) {
            ctx.globalAlpha = 0.4;
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                ctx.strokeStyle = `rgba(0, ${100 + Math.random() * 100}, 0, 0.6)`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.random() * 4 - 2, y - Math.random() * 6);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        function addSandPattern(ctx, size) {
            ctx.globalAlpha = 0.2;
            for (let y = 0; y < size; y += 2) {
                for (let x = 0; x < size; x += 2) {
                    if (Math.random() > 0.7) {
                        ctx.fillStyle = `rgba(${200 + Math.random() * 55}, ${180 + Math.random() * 55}, ${120 + Math.random() * 55}, 0.3)`;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }
            ctx.globalAlpha = 1;
        }

        function addFluidPattern(ctx, size) {
            ctx.globalAlpha = 0.3;
            for (let i = 0; i < 5; i++) {
                const gradient = ctx.createRadialGradient(
                    Math.random() * size, Math.random() * size, 0,
                    Math.random() * size, Math.random() * size, size * 0.5
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, size, size);
            }
            ctx.globalAlpha = 1;
        }

        function addGenericPattern(ctx, size) {
            ctx.globalAlpha = 0.1;
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                ctx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.1)`;
                ctx.fillRect(x, y, 1, 1);
            }
            ctx.globalAlpha = 1;
        }

        // ============ COLLATZ FUNCTIONS ============
        function collatz(n) {
            return n % 2 === 0 ? n / 2 : 3 * n + 1;
        }

        function getCollatzSequence(seed) {
            const sequence = [seed];
            let current = seed;
            let maxValue = seed;
            
            while (current !== 1) {
                current = collatz(current);
                sequence.push(current);
                maxValue = Math.max(maxValue, current);
            }
            
            return { sequence, maxValue };
        }

        // ============ ENHANCED TERRAIN GENERATION ============
        class SimplexNoise {
            constructor(seed = 0) {
                this.seed = seed;
                this.perm = this.generatePermutation();
            }

            generatePermutation() {
                const perm = [];
                for (let i = 0; i < 256; i++) {
                    perm[i] = i;
                }
                
                let rng = this.seed;
                for (let i = 255; i > 0; i--) {
                    rng = (rng * 1664525 + 1013904223) >>> 0;
                    const j = rng % (i + 1);
                    [perm[i], perm[j]] = [perm[j], perm[i]];
                }
                
                for (let i = 0; i < 256; i++) {
                    perm[i + 256] = perm[i];
                }
                
                return perm;
            }

            noise2D(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                
                x -= Math.floor(x);
                y -= Math.floor(y);
                
                const u = this.fade(x);
                const v = this.fade(y);
                
                const A = this.perm[X] + Y;
                const B = this.perm[X + 1] + Y;
                
                return this.lerp(v,
                    this.lerp(u, this.grad(this.perm[A], x, y),
                               this.grad(this.perm[B], x - 1, y)),
                    this.lerp(u, this.grad(this.perm[A + 1], x, y - 1),
                               this.grad(this.perm[B + 1], x - 1, y - 1))
                );
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
        }

        function generateHeightMap(seed, scale, size) {
            updateLoadingStatus('Generating Collatz sequence...');
            const { sequence, maxValue } = getCollatzSequence(seed);
            state.sequence = sequence;
            state.maxValue = maxValue;
            
            updateLoadingStatus('Creating noise generators...');
            const noise1 = new SimplexNoise(seed);
            const noise2 = new SimplexNoise(seed * 137);
            
            const heightMap = [];
            const frequency = scale / 100;
            
            updateLoadingStatus('Generating terrain heightmap...');
            
            for (let z = 0; z < size; z++) {
                heightMap[z] = [];
                for (let x = 0; x < size; x++) {
                    let elevation = 0;
                    
                    // Multi-octave noise for realistic terrain
                    elevation += noise1.noise2D(x * frequency, z * frequency) * 0.6;
                    elevation += noise1.noise2D(x * frequency * 2, z * frequency * 2) * 0.3;
                    elevation += noise1.noise2D(x * frequency * 4, z * frequency * 4) * 0.1;
                    
                    // Collatz mathematical influence
                    const seqIndex = Math.floor((x + z) / 5) % sequence.length;
                    const collatzMod = sequence[seqIndex] / maxValue;
                    
                    // Enhanced terrain features based on Collatz values
                    if (sequence[seqIndex] > maxValue * 0.7) {
                        elevation += noise2.noise2D(x * frequency * 0.5, z * frequency * 0.5) * 0.4 * collatzMod;
                    }
                    
                    if (sequence[seqIndex] < maxValue * 0.3) {
                        elevation -= 0.2 * (1 - collatzMod);
                    }
                    
                    elevation = (elevation + 1) / 2;
                    elevation = Math.max(0, Math.min(1, elevation));
                    
                    heightMap[z][x] = elevation;
                }
                
                // Update progress
                const progress = (z / size) * 60; // 60% for heightmap generation
                updateProgress(progress);
            }
            
            return heightMap;
        }

        /**
         * Gets appropriate material type based on elevation and current texture pack
         * @param {number} elevation - Normalized elevation (0-1)
         * @returns {string} Material type key
         */
        function getMaterialTypeForElevation(elevation) {
            const pack = TEXTURE_PACKS[state.currentTexturePack];
            const materialKeys = Object.keys(pack.materials);
            
            // Map elevation ranges to material types
            if (elevation <= 0.3) return materialKeys[0] || 'water';
            if (elevation <= 0.4) return materialKeys[1] || 'sand';
            if (elevation <= 0.7) return materialKeys[2] || 'grass';
            if (elevation <= 0.9) return materialKeys[3] || 'stone';
            return materialKeys[4] || 'snow';
        }

        function createEnhancedVoxelTerrain(heightMap) {
            const size = heightMap.length;
            state.world.terrainData = heightMap;
            state.world.size = size;
            
            updateLoadingStatus('Clearing previous terrain...');
            
            // Clear existing terrain
            state.world.blocks.forEach(mesh => {
                state.scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material && mesh.material.dispose) mesh.material.dispose();
            });
            state.world.blocks.clear();
            
            // Clear material cache when switching texture packs
            materialCache.forEach(material => material.dispose());
            materialCache.clear();
            
            updateLoadingStatus('Grouping blocks by material...');
            
            // Group blocks by material type for optimal rendering
            const materialGroups = new Map();
            let totalBlocks = 0;
            
            for (let z = 0; z < size; z++) {
                for (let x = 0; x < size; x++) {
                    const elevation = heightMap[z][x];
                    const height = Math.floor(elevation * state.world.maxHeight);
                    
                    // Create blocks from ground up to height
                    for (let y = 0; y <= height; y++) {
                        const blockElevation = y / state.world.maxHeight;
                        const materialType = getMaterialTypeForElevation(blockElevation);
                        
                        if (!materialGroups.has(materialType)) {
                            materialGroups.set(materialType, []);
                        }
                        materialGroups.get(materialType).push({ x, y, z });
                        totalBlocks++;
                    }
                }
                
                // Update progress during grouping
                const progress = 60 + (z / size) * 20; // 20% for grouping
                updateProgress(progress);
            }
            
            updateLoadingStatus('Creating optimized meshes...');
            
            // Create optimized geometry for each material group
            const sharedBlockGeometry = new THREE.BoxGeometry(1, 1, 1);
            sharedBlockGeometry.computeBoundingSphere();
            let meshCount = 0;
            let groupIndex = 0;
            
            materialGroups.forEach((positions, materialType) => {
                if (positions.length === 0) return;
                
                updateLoadingStatus(`Creating ${materialType} blocks...`);
                
                const pack = TEXTURE_PACKS[state.currentTexturePack];
                const material = createEnhancedMaterial(materialType, pack.materials[materialType]);
                
                // Use instanced mesh for better performance
                if (positions.length > CONFIG.WORLD.INSTANCING_THRESHOLD) {
                    const instancedMesh = new THREE.InstancedMesh(
                        sharedBlockGeometry,
                        material,
                        positions.length
                    );
                    
                    // Proper bounding sphere for frustum culling
                    const center = new THREE.Vector3(size/2, state.world.maxHeight/2, size/2);
                    const radius = Math.sqrt((size/2)**2 + (size/2)**2 + (state.world.maxHeight/2)**2) * 1.2;
                    
                    const geometry = sharedBlockGeometry.clone();
                    geometry.boundingSphere = new THREE.Sphere(center, radius);
                    instancedMesh.geometry = geometry;
                    instancedMesh.frustumCulled = true;
                    
                    // Enhanced shadow properties
                    instancedMesh.castShadow = true;
                    instancedMesh.receiveShadow = true;
                    
                    const matrix = new THREE.Matrix4();
                    positions.forEach((pos, index) => {
                        matrix.setPosition(pos.x, pos.y, pos.z);
                        instancedMesh.setMatrixAt(index, matrix);
                    });
                    instancedMesh.instanceMatrix.needsUpdate = true;
                    
                    state.scene.add(instancedMesh);
                    state.world.blocks.set(`instanced_${materialType}`, instancedMesh);
                    meshCount++;
                } else {
                    // Individual meshes for small groups
                    positions.forEach(pos => {
                        const mesh = new THREE.Mesh(sharedBlockGeometry, material);
                        mesh.position.set(pos.x, pos.y, pos.z);
                        mesh.frustumCulled = true;
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        
                        state.scene.add(mesh);
                        const key = `${pos.x},${pos.y},${pos.z}`;
                        state.world.blocks.set(key, mesh);
                        meshCount++;
                    });
                }
                
                // Update progress during mesh creation
                groupIndex++;
                const progress = 80 + (groupIndex / materialGroups.size) * 20;
                updateProgress(progress);
            });
            
            updateLoadingStatus('Finalizing terrain...');
            
            console.log(`🚀 Enhanced terrain: ${totalBlocks} blocks, ${meshCount} meshes, ${materialGroups.size} materials`);
            updateBlockCount(totalBlocks);
            updateMeshCount(meshCount);
            
            // Update texture pack display
            document.getElementById('currentTexturePack').textContent = TEXTURE_PACKS[state.currentTexturePack].name;
            
            // Place player at reasonable height
            const centerX = Math.floor(size / 2);
            const centerZ = Math.floor(size / 2);
            const centerHeight = Math.floor(heightMap[centerZ][centerX] * state.world.maxHeight) + 5;
            state.player.position.set(centerX, centerHeight, centerZ);
            
            updateProgress(100);
            updateLoadingStatus('Complete!');
            
            // Generate map features after terrain is created
            generateMapFeatures();
        }
      

        // ============ ENHANCED THREE.JS SETUP ============
        function initThreeJS() {
            // Scene with enhanced settings
            state.scene = new THREE.Scene();
            state.scene.background = new THREE.Color(0x87CEEB);
            state.scene.fog = new THREE.Fog(0x87CEEB, CONFIG.RENDERING.FOG_NEAR, CONFIG.RENDERING.FOG_FAR);
            
            // Camera
            state.camera = new THREE.PerspectiveCamera(
                CONFIG.RENDERING.FOV,
                window.innerWidth / window.innerHeight,
                CONFIG.RENDERING.NEAR,
                CONFIG.RENDERING.FAR
            );
            state.camera.matrixAutoUpdate = true;
            
            // Enhanced renderer
            state.renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('renderer'),
                antialias: true,
                powerPreference: "high-performance",
                stencil: false,
                depth: true
            });
            state.renderer.setSize(window.innerWidth, window.innerHeight);
            state.renderer.setPixelRatio(Math.min(window.devicePixelRatio, CONFIG.RENDERING.MAX_PIXEL_RATIO));
            
            // Enhanced shadow settings
            state.renderer.shadowMap.enabled = true;
            state.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            state.renderer.shadowMap.autoUpdate = true;
            
            // Enhanced rendering settings
            state.renderer.outputEncoding = THREE.sRGBEncoding;
            state.renderer.toneMapping = THREE.ACESFilmicToneMapping;
            state.renderer.toneMappingExposure = 1.0;
            state.renderer.physicallyCorrectLights = true;
            
            // Enhanced lighting setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            state.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(100, 200, 100);
            directionalLight.castShadow = true;
            
            // Enhanced shadow camera
            directionalLight.shadow.mapSize.width = CONFIG.RENDERING.SHADOW_MAP_SIZE;
            directionalLight.shadow.mapSize.height = CONFIG.RENDERING.SHADOW_MAP_SIZE;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 400;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.bias = -0.0001;
            directionalLight.shadow.normalBias = 0.02;
            
            state.scene.add(directionalLight);
            
            // Add hemisphere light for better ambient lighting
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x4169E1, 0.3);
            state.scene.add(hemisphereLight);
            
            console.log('🎮 Enhanced Three.js initialized');
        }

        // ============ ENHANCED CONTROLS ============
        function initControls() {
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            
            const canvas = document.getElementById('renderer');
            canvas.addEventListener('click', () => {
                if (!state.isPaused && !state.isMapOpen && !state.isPointerLocked) {
                    requestPointerLock();
                }
            });
            
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('pointerlockerror', onPointerLockError);
            
            window.addEventListener('resize', onWindowResize);
        }

        function onKeyDown(event) {
            if (event.code === 'Escape') {
                if (!state.isMapOpen) {
                    togglePause();
                }
                event.preventDefault();
                return;
            }

            if (event.code === 'KeyM') {
                toggleMap();
                event.preventDefault();
                return;
            }

            if (event.code === 'KeyP') {
                togglePerformanceOverlay();
                event.preventDefault();
                return;
            }

            if (event.code === 'KeyT' && !state.isPaused) {
                cycleTexturePack();
                event.preventDefault();
                return;
            }
            
            if (state.isPaused || state.isMapOpen) return;
            
            switch (event.code) {
                case 'KeyW': state.controls.forward = true; break;
                case 'KeyS': state.controls.backward = true; break;
                case 'KeyA': state.controls.left = true; break;
                case 'KeyD': state.controls.right = true; break;
                case 'Space': 
                    state.controls.jump = true; 
                    event.preventDefault(); 
                    break;
                case 'ShiftLeft': state.controls.run = true; break;
                case 'KeyF': 
                    toggleFullscreen(); 
                    event.preventDefault(); 
                    break;
            }
        }

        function onKeyUp(event) {
            if (state.isPaused || state.isMapOpen) return;
            
            switch (event.code) {
                case 'KeyW': state.controls.forward = false; break;
                case 'KeyS': state.controls.backward = false; break;
                case 'KeyA': state.controls.left = false; break;
                case 'KeyD': state.controls.right = false; break;
                case 'Space': state.controls.jump = false; break;
                case 'ShiftLeft': state.controls.run = false; break;
            }
        }

        function onMouseMove(event) {
            if (!state.isPointerLocked || state.isPaused || state.isMapOpen) return;
            
            const sensitivity = state.player.mouseSensitivity;
            
            state.player.yaw -= event.movementX * sensitivity;
            
            while (state.player.yaw > Math.PI) state.player.yaw -= 2 * Math.PI;
            while (state.player.yaw < -Math.PI) state.player.yaw += 2 * Math.PI;
            
            state.player.pitch -= event.movementY * sensitivity;
            state.player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, state.player.pitch));
        }

        function requestPointerLock() {
            if (!state.isPointerLocked && !state.isPaused && !state.isMapOpen) {
                document.body.requestPointerLock();
            }
        }

        function onPointerLockChange() {
            const wasLocked = state.isPointerLocked;
            state.isPointerLocked = document.pointerLockElement === document.body;
            
            const indicator = document.getElementById('statusIndicator');
            if (state.isPointerLocked) {
                indicator.textContent = '🎮 Mouse look enabled';
                indicator.className = 'status-indicator locked';
            } else {
                indicator.textContent = '🖱️ Click to enable mouse look';
                indicator.className = 'status-indicator unlocked';
            }
            
            if (wasLocked && !state.isPointerLocked && !state.isPaused && !state.isMapOpen) {
                setTimeout(() => {
                    if (!state.isPointerLocked && !state.isPaused && !state.isMapOpen) {
                        togglePause();
                    }
                }, 100);
            }
        }

        function onPointerLockError() {
            console.warn('Pointer lock failed');
            const indicator = document.getElementById('statusIndicator');
            indicator.textContent = '❌ Mouse lock failed - try clicking again';
            indicator.className = 'status-indicator unlocked';
        }

        function onWindowResize() {
            state.camera.aspect = window.innerWidth / window.innerHeight;
            state.camera.updateProjectionMatrix();
            state.renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============ ENHANCED UI FUNCTIONS ============
        function initUI() {
            initializeTexturePacks();
            
            // Enhanced range inputs
            const scaleInput = document.getElementById('scale');
            const heightInput = document.getElementById('height');
            const speedInput = document.getElementById('moveSpeed');
            const sensitivityInput = document.getElementById('mouseSensitivity');
            
            scaleInput.addEventListener('input', (e) => {
                document.getElementById('scaleValue').textContent = e.target.value;
            });
            
            heightInput.addEventListener('input', (e) => {
                document.getElementById('heightValue').textContent = e.target.value;
                state.world.maxHeight = parseInt(e.target.value);
            });

            speedInput.addEventListener('input', (e) => {
                document.getElementById('speedValue').textContent = e.target.value;
                state.player.speed = parseInt(e.target.value);
            });

            sensitivityInput.addEventListener('input', (e) => {
                document.getElementById('sensitivityValue').textContent = e.target.value;
                state.player.mouseSensitivity = parseFloat(e.target.value) * CONFIG.PLAYER.BASE_MOUSE_SENSITIVITY;
            });
        }

        function initializeTexturePacks() {
            const container = document.getElementById('texturePackSelector');
            container.innerHTML = '';
            
            Object.entries(TEXTURE_PACKS).forEach(([key, pack]) => {
                const option = document.createElement('div');
                option.className = 'texture-pack-option';
                if (key === state.currentTexturePack) option.classList.add('active');
                option.onclick = () => selectTexturePack(key);
                
                const preview = document.createElement('div');
                preview.className = 'texture-pack-preview';
                
                // Create visual preview based on pack materials
                const colors = Object.values(pack.materials).slice(0, 3);
                preview.style.background = `linear-gradient(45deg, ${colors.map(m => `#${m.color.toString(16).padStart(6, '0')}`).join(', ')})`;
                
                const name = document.createElement('div');
                name.className = 'texture-pack-name';
                name.textContent = pack.name;
                
                option.appendChild(preview);
                option.appendChild(name);
                container.appendChild(option);
            });
        }

        function selectTexturePack(key) {
            if (state.currentTexturePack === key) return;
            
            state.currentTexturePack = key;
            
            // Update UI
            document.querySelectorAll('.texture-pack-option').forEach(el => el.classList.remove('active'));
            const selectedOption = Array.from(document.querySelectorAll('.texture-pack-option')).find(el => 
                el.querySelector('.texture-pack-name').textContent === TEXTURE_PACKS[key].name
            );
            if (selectedOption) selectedOption.classList.add('active');
            
            // Regenerate terrain with new materials
            if (state.world.terrainData) {
                showLoading(true);
                setTimeout(() => {
                    createEnhancedVoxelTerrain(state.world.terrainData);
                    updateStats();
                    
                    // Update map if it's open
                    if (state.isMapOpen) {
                        console.log('🗺️ Updating open map with new texture pack');
                        renderMap();
                        updateMapLegend();
                        updatePlayerMapInfo();
                    }
                    
                    showLoading(false);
                }, 100);
            }
        }

        function cycleTexturePack() {
            const keys = Object.keys(TEXTURE_PACKS);
            const currentIndex = keys.indexOf(state.currentTexturePack);
            const nextIndex = (currentIndex + 1) % keys.length;
            selectTexturePack(keys[nextIndex]);
        }

        function togglePerformanceOverlay() {
            state.performanceVisible = !state.performanceVisible;
            const overlay = document.getElementById('performanceOverlay');
            overlay.classList.toggle('visible', state.performanceVisible);
        }

        function togglePause() {
            state.isPaused = !state.isPaused;
            
            if (state.isPaused) {
                if (state.isPointerLocked) {
                    document.exitPointerLock();
                }
                document.getElementById('pauseOverlay').classList.add('active');
                document.body.style.cursor = 'default';
            } else {
                document.getElementById('pauseOverlay').classList.remove('active');
                
                if (!state.isMapOpen) {
                    document.body.style.cursor = 'none';
                    setTimeout(() => {
                        if (!state.isPaused && !state.isMapOpen) {
                            requestPointerLock();
                        }
                    }, 100);
                }
            }
        }

        function resumeGame() {
            if (state.isPaused) {
                togglePause();
            }
        }

        function resetCamera() {
            const size = state.world.size;
            const centerX = Math.floor(size / 2);
            const centerZ = Math.floor(size / 2);
            let centerHeight = 30;
            
            if (state.world.terrainData) {
                centerHeight = Math.floor(state.world.terrainData[centerZ][centerX] * state.world.maxHeight) + 5;
            }
            
            state.player.position.set(centerX, centerHeight, centerZ);
            state.player.yaw = 0;
            state.player.pitch = 0;
            state.player.velocity.set(0, 0, 0);
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        function exportScreenshot() {
            const canvas = state.renderer.domElement;
            const link = document.createElement('a');
            link.download = `collatz-terrain-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        function showLoading(show) {
            const overlay = document.getElementById('loadingOverlay');
            overlay.classList.toggle('active', show);
            if (!show) {
                document.getElementById('progressBar').style.width = '0%';
            }
        }

        function updateProgress(progress) {
            document.getElementById('progressBar').style.width = `${progress}%`;
        }

        function updateLoadingStatus(status) {
            document.getElementById('loadingStatus').textContent = status;
        }

        function updateStats() {
            document.getElementById('sequenceLength').textContent = state.sequence.length.toLocaleString();
            document.getElementById('maxValue').textContent = state.maxValue.toLocaleString();
            document.getElementById('currentSeed').textContent = document.getElementById('seed').value;
            
            const size = state.world.size;
            document.getElementById('worldSizeStat').textContent = `${size}x${size}`;
            
            const truncated = state.sequence.length > 15;
            const displaySeq = truncated ? state.sequence.slice(0, 15) : state.sequence;
            const sequenceText = displaySeq.join(' → ') + (truncated ? ' → ...' : '');
            document.getElementById('sequenceMini').textContent = sequenceText;
        }

        function updateBlockCount(count) {
            const formattedCount = count.toLocaleString();
            document.getElementById('blockCount').textContent = formattedCount;
            document.getElementById('blockCountPause').textContent = formattedCount;
        }

        function updateMeshCount(count) {
            document.getElementById('meshCount').textContent = count.toLocaleString();
        }

        function updateRenderStats() {
            if (!state.performanceVisible) return;
            
            const info = state.renderer.info;
            
            document.getElementById('drawCalls').textContent = info.render.calls;
            document.getElementById('triangles').textContent = info.render.triangles.toLocaleString();
            
            // Memory estimation
            const memoryMB = (info.memory.geometries * 0.1 + info.memory.textures * 0.5).toFixed(1);
            document.getElementById('memory').textContent = `${memoryMB}MB`;
            
            // Color coding for performance
            const drawCallsEl = document.getElementById('drawCalls');
            const trianglesEl = document.getElementById('triangles');
            
            drawCallsEl.className = info.render.calls > 100 ? 'perf-value perf-warning' : 'perf-value perf-good';
            trianglesEl.className = info.render.triangles > 100000 ? 'perf-value perf-warning' : 'perf-value perf-good';
        }

        // ============ PHYSICS & MOVEMENT (unchanged) ============
        function updatePlayer(deltaTime) {
            if (state.isPaused || state.isMapOpen) return;
            
            const baseSpeed = state.player.speed;
            const currentSpeed = state.controls.run ? baseSpeed * CONFIG.PLAYER.RUN_MULTIPLIER : baseSpeed;
            
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);
            const movement = new THREE.Vector3(0, 0, 0);
            
            if (state.controls.forward) movement.add(forward);
            if (state.controls.backward) movement.sub(forward);
            if (state.controls.right) movement.add(right);
            if (state.controls.left) movement.sub(right);
            
            if (movement.length() > 0) {
                movement.normalize();
                
                const rotatedMovement = new THREE.Vector3();
                const yaw = -state.player.yaw;
                rotatedMovement.x = movement.x * Math.cos(yaw) - movement.z * Math.sin(yaw);
                rotatedMovement.z = movement.x * Math.sin(yaw) + movement.z * Math.cos(yaw);
                
                rotatedMovement.multiplyScalar(currentSpeed * deltaTime);
                
                state.player.velocity.x = rotatedMovement.x;
                state.player.velocity.z = rotatedMovement.z;
            } else {
                state.player.velocity.x *= CONFIG.PLAYER.FRICTION;
                state.player.velocity.z *= CONFIG.PLAYER.FRICTION;
            }
            
            if (state.controls.jump && state.player.onGround) {
                state.player.velocity.y = CONFIG.PLAYER.JUMP_POWER;
                state.player.onGround = false;
            }
            
            if (!state.player.onGround) {
                state.player.velocity.y -= CONFIG.PLAYER.GRAVITY * deltaTime;
            }
            
            const oldPosition = state.player.position.clone();
            state.player.position.add(state.player.velocity.clone().multiplyScalar(deltaTime));
            
            checkCollisions(oldPosition);
            updateCamera();
        }

        function checkCollisions(oldPosition) {
            const pos = state.player.position;
            const radius = CONFIG.PLAYER.COLLISION_RADIUS;
            
            const groundY = Math.floor(pos.y - 0.1);
            const groundCollision = checkBlockAt(Math.floor(pos.x), groundY, Math.floor(pos.z));
            
            if (groundCollision || pos.y <= 0) {
                if (state.player.velocity.y <= 0) {
                    state.player.position.y = groundY + 1;
                    state.player.velocity.y = 0;
                    state.player.onGround = true;
                }
            } else {
                state.player.onGround = false;
            }
            
            const playerY = Math.floor(pos.y);
            const headY = Math.floor(pos.y + CONFIG.PLAYER.HEIGHT * 0.8);
            
            const checkPoints = [
                { x: pos.x + radius, z: pos.z, axis: 'x' },
                { x: pos.x - radius, z: pos.z, axis: 'x' },
                { x: pos.x, z: pos.z + radius, axis: 'z' },
                { x: pos.x, z: pos.z - radius, axis: 'z' }
            ];
            
            for (const point of checkPoints) {
                const blockX = Math.floor(point.x);
                const blockZ = Math.floor(point.z);
                
                if (checkBlockAt(blockX, playerY, blockZ) || checkBlockAt(blockX, headY, blockZ)) {
                    if (point.axis === 'x') {
                        if (point.x > pos.x) {
                            pos.x = blockX - radius;
                        } else {
                            pos.x = blockX + 1 + radius;
                        }
                        state.player.velocity.x = 0;
                    } else {
                        if (point.z > pos.z) {
                            pos.z = blockZ - radius;
                        } else {
                            pos.z = blockZ + 1 + radius;
                        }
                        state.player.velocity.z = 0;
                    }
                }
            }
            
            const ceilY = Math.floor(pos.y + CONFIG.PLAYER.HEIGHT);
            if (checkBlockAt(Math.floor(pos.x), ceilY, Math.floor(pos.z))) {
                if (state.player.velocity.y > 0) {
                    state.player.position.y = ceilY - CONFIG.PLAYER.HEIGHT;
                    state.player.velocity.y = 0;
                }
            }
            
            const size = state.world.size;
            pos.x = Math.max(radius, Math.min(size - radius, pos.x));
            pos.z = Math.max(radius, Math.min(size - radius, pos.z));
        }

        function checkBlockAt(x, y, z) {
            if (x < 0 || z < 0 || x >= state.world.size || z >= state.world.size || y < 0) {
                return false;
            }
            
            if (state.world.terrainData) {
                const elevation = state.world.terrainData[z][x];
                const height = Math.floor(elevation * state.world.maxHeight);
                return y <= height;
            }
            
            const key = `${x},${y},${z}`;
            return state.world.blocks.has(key);
        }

        function updateCamera() {
            state.camera.position.copy(state.player.position);
            state.camera.position.y += CONFIG.PLAYER.HEIGHT;
            state.camera.rotation.set(state.player.pitch, state.player.yaw, 0, 'YXZ');
        }

        // ============ GENERATION FUNCTIONS ============
        function generateTerrain() {
            showLoading(true);
            
            const seed = parseInt(document.getElementById('seed').value) || 27;
            const scale = parseFloat(document.getElementById('scale').value);
            const size = parseInt(document.getElementById('worldSize').value);
            state.world.maxHeight = parseInt(document.getElementById('height').value);
            
            setTimeout(() => {
                try {
                    const heightMap = generateHeightMap(seed, scale, size);
                    createEnhancedVoxelTerrain(heightMap);
                    updateStats();
                    
                    console.log('🎮 Terrain generated successfully - data available for map:', !!state.world.terrainData);
                    
                    // Update map if it's open
                    if (state.isMapOpen) {
                        console.log('🗺️ Updating open map with new terrain');
                        renderMap();
                        updateMapLegend();
                        updatePlayerMapInfo();
                    }
                } catch (error) {
                    console.error('Error generating terrain:', error);
                    updateLoadingStatus('Error generating terrain!');
                } finally {
                    setTimeout(() => showLoading(false), 500);
                }
            }, 100);
        }

        function randomSeed() {
            const seed = Math.floor(Math.random() * 99999) + 1;
            document.getElementById('seed').value = seed;
            generateTerrain();
        }

        function toggleAnimation() {
            const btn = document.getElementById('animateBtn');
            
            if (state.animationFrame) {
                clearTimeout(state.animationFrame);
                state.animationFrame = null;
                btn.textContent = '▶️ Animate';
                btn.classList.remove('secondary');
            } else {
                btn.textContent = '⏸️ Stop';
                btn.classList.add('secondary');
                animateSeeds();
            }
        }

        function animateSeeds() {
            if (!state.animationFrame) return;
            
            let seed = parseInt(document.getElementById('seed').value);
            seed = collatz(seed);
            if (seed === 1) seed = Math.floor(Math.random() * 1000) + 1;
            
            document.getElementById('seed').value = seed;
            generateTerrain();
            
            state.animationFrame = setTimeout(animateSeeds, 3000);
        }

        // ============ ENHANCED GAME LOOP ============
        function gameLoop(currentTime) {
            const deltaTime = Math.min((currentTime - state.lastTime) / 1000, 0.1);
            state.lastTime = currentTime;
            
            // Enhanced FPS counter
            state.frameCount++;
            if (currentTime - state.lastFpsUpdate > 500) {
                state.fpsCounter = Math.round(state.frameCount * 1000 / (currentTime - state.lastFpsUpdate));
                const fpsElement = document.getElementById('fpsCounter');
                fpsElement.textContent = state.fpsCounter;
                
                // Enhanced performance color coding
                if (state.fpsCounter >= 50) {
                    fpsElement.className = 'hud-value perf-good';
                } else if (state.fpsCounter >= 30) {
                    fpsElement.className = 'hud-value perf-warning';
                } else {
                    fpsElement.className = 'hud-value perf-error';
                }
                
                state.frameCount = 0;
                state.lastFpsUpdate = currentTime;
                
                // Update render stats
                updateRenderStats();
            }
            
            // Store previous position for distance tracking
            const prevPosition = state.player.position.clone();
            
            updatePlayer(deltaTime);
            
            // Track distance traveled (only when not paused or in map)
            if (!state.isPaused && !state.isMapOpen) {
                const distance = prevPosition.distanceTo(state.player.position);
                state.achievements.distanceTraveled += distance;
                
                // Check for nearby features every few frames
                if (state.frameCount % 30 === 0) { // Check every 30 frames (~0.5 seconds at 60fps)
                    checkNearbyFeatures();
                }
            }
            
            // Update map if it's open (throttled to every 10 frames for performance but still responsive)
            if (state.isMapOpen && state.frameCount % 10 === 0) {
                renderMap();
                updatePlayerMapInfo();
            }
            
            state.renderer.render(state.scene, state.camera);
            
            requestAnimationFrame(gameLoop);
        }

        // ============ MAP FUNCTIONS ============
        function toggleMap() {
            state.isMapOpen = !state.isMapOpen;
            
            if (state.isMapOpen) {
                // Open map: release pointer lock and show map (independent of main menu)
                if (state.isPointerLocked) {
                    document.exitPointerLock();
                }
                document.getElementById('mapOverlay').classList.add('active');
                document.body.style.cursor = 'default';
                
                // Add mouse move listener for coordinate display
                const canvas = document.getElementById('mapCanvas');
                canvas.addEventListener('mousemove', onMapMouseMove);
                
                // Render the map
                console.log('🗺️ Opening map - terrain data available:', !!state.world.terrainData);
                renderMap();
                updateMapLegend();
                updateMapCounters();
                
                // Update player info
                updatePlayerMapInfo();
            } else {
                // Close map: hide map overlay
                document.getElementById('mapOverlay').classList.remove('active');
                
                // Remove mouse move listener
                const canvas = document.getElementById('mapCanvas');
                canvas.removeEventListener('mousemove', onMapMouseMove);
                
                // Only re-enable pointer lock and change cursor if main menu is not open
                if (!state.isPaused) {
                    document.body.style.cursor = 'none';
                    setTimeout(() => {
                        if (!state.isPaused && !state.isMapOpen) {
                            requestPointerLock();
                        }
                    }, 100);
                }
            }
        }

        function renderMap() {
            if (!state.world.terrainData) return;
            
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const size = state.world.size;
            
            // Set canvas size explicitly
            const mapSize = 400;
            canvas.width = mapSize;
            canvas.height = mapSize;
            canvas.style.width = mapSize + 'px';
            canvas.style.height = mapSize + 'px';
            
            // Clear canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, mapSize, mapSize);
            
            // Calculate scale
            const scale = mapSize / size;
            
            // Create image data for faster rendering
            const imageData = ctx.createImageData(mapSize, mapSize);
            const data = imageData.data;
            
            // Get current texture pack for colors
            const pack = TEXTURE_PACKS[state.currentTexturePack];
            
            // Render terrain using elevation mapping to materials
            for (let z = 0; z < size; z++) {
                for (let x = 0; x < size; x++) {
                    const elevation = state.world.terrainData[z][x];
                    
                    // Get material type and color for this elevation
                    const materialType = getMaterialTypeForElevation(elevation);
                    const materialData = pack.materials[materialType];
                    let color = [128, 128, 128]; // Default gray
                    
                    if (materialData && materialData.color) {
                        // Convert hex color to RGB array
                        const hexColor = materialData.color;
                        color = [
                            (hexColor >> 16) & 255,
                            (hexColor >> 8) & 255,
                            hexColor & 255
                        ];
                    }
                    
                    // Calculate pixel positions
                    const startX = Math.floor(x * scale);
                    const startY = Math.floor(z * scale);
                    const endX = Math.floor((x + 1) * scale);
                    const endY = Math.floor((z + 1) * scale);
                    
                    // Fill the pixel area for this terrain cell
                    for (let py = startY; py < endY && py < mapSize; py++) {
                        for (let px = startX; px < endX && px < mapSize; px++) {
                            const index = (py * mapSize + px) * 4;
                            data[index] = color[0];     // Red
                            data[index + 1] = color[1]; // Green
                            data[index + 2] = color[2]; // Blue
                            data[index + 3] = 255;      // Alpha
                        }
                    }
                }
            }
            
            // Put the image data to canvas
            ctx.putImageData(imageData, 0, 0);
            
            // Draw treasures
            state.mapFeatures.treasures.forEach(treasure => {
                if (!treasure.found) {
                    const treasureX = (treasure.x / size) * mapSize;
                    const treasureZ = (treasure.z / size) * mapSize;
                    
                    // Treasure glow effect
                    const gradient = ctx.createRadialGradient(treasureX, treasureZ, 0, treasureX, treasureZ, 12);
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(treasureX - 12, treasureZ - 12, 24, 24);
                    
                    // Treasure icon
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(treasureX, treasureZ, 5, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = '#FFA500';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
            
            // Draw waypoints
            state.mapFeatures.waypoints.forEach((waypoint, index) => {
                const waypointX = (waypoint.x / size) * mapSize;
                const waypointZ = (waypoint.z / size) * mapSize;
                
                // Waypoint marker
                ctx.fillStyle = waypoint === state.mapFeatures.selectedWaypoint ? '#00FF00' : '#00BFFF';
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(waypointX, waypointZ, 4, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // Waypoint number
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText((index + 1).toString(), waypointX, waypointZ + 3);
            });
            
            // Draw discoveries
            state.mapFeatures.discoveries.forEach(discovery => {
                const discX = (discovery.x / size) * mapSize;
                const discZ = (discovery.z / size) * mapSize;
                
                // Discovery marker - star shape
                ctx.fillStyle = discovery.found ? '#9932CC' : '#FF69B4';
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1;
                drawStar(ctx, discX, discZ, 6, 5);
            });
            
            // Draw player position
            const playerX = (state.player.position.x / size) * mapSize;
            const playerZ = (state.player.position.z / size) * mapSize;
            
            // Player dot (larger and more visible)
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.arc(playerX, playerZ, 6, 0, 2 * Math.PI);
            ctx.fill();
            
            // Player border (white outline)
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(playerX, playerZ, 6, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Fixed player direction indicator
            const directionLength = 20;
            // Convert 3D yaw to 2D map direction (fixed the reversed issue)
            const mapAngle = state.player.yaw + Math.PI; // Add PI to fix reversed direction
            const directionX = playerX + Math.sin(mapAngle) * directionLength;
            const directionY = playerZ - Math.cos(mapAngle) * directionLength; // Negative cos for proper direction
            
            ctx.strokeStyle = '#FFFF00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(playerX, playerZ);
            ctx.lineTo(directionX, directionY);
            ctx.stroke();
            
            // Arrow head
            const headLength = 8;
            const headAngle = Math.PI / 6;
            const angle = Math.atan2(directionY - playerZ, directionX - playerX);
            
            ctx.beginPath();
            ctx.moveTo(directionX, directionY);
            ctx.lineTo(
                directionX - headLength * Math.cos(angle - headAngle),
                directionY - headLength * Math.sin(angle - headAngle)
            );
            ctx.moveTo(directionX, directionY);
            ctx.lineTo(
                directionX - headLength * Math.cos(angle + headAngle),
                directionY - headLength * Math.sin(angle + headAngle)
            );
            ctx.stroke();
            
            // Check for nearby treasures and discoveries
            checkNearbyFeatures();
        }

        function drawStar(ctx, x, y, outerRadius, points) {
            const innerRadius = outerRadius * 0.4;
            const angle = Math.PI / points;
            
            ctx.beginPath();
            for (let i = 0; i < 2 * points; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const currentAngle = i * angle;
                const pointX = x + Math.cos(currentAngle) * radius;
                const pointY = y + Math.sin(currentAngle) * radius;
                
                if (i === 0) {
                    ctx.moveTo(pointX, pointY);
                } else {
                    ctx.lineTo(pointX, pointY);
                }
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function onMapClick(event) {
            const canvas = document.getElementById('mapCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Convert canvas coordinates to world coordinates
            const size = state.world.size;
            const mapSize = 400;
            const worldX = Math.floor((x / mapSize) * size);
            const worldZ = Math.floor((y / mapSize) * size);
            
            // Place waypoint
            const waypoint = { x: worldX, z: worldZ };
            state.mapFeatures.waypoints.push(waypoint);
            state.mapFeatures.selectedWaypoint = waypoint;
            state.achievements.waypointsPlaced++;
            
            // Update counters
            updateMapCounters();
            renderMap();
            
            console.log(`📍 Waypoint placed at (${worldX}, ${worldZ})`);
        }

        function onMapMouseMove(event) {
            const canvas = document.getElementById('mapCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Convert to world coordinates
            const size = state.world.size;
            const mapSize = 400;
            const worldX = Math.floor((x / mapSize) * size);
            const worldZ = Math.floor((y / mapSize) * size);
            
            // Update coordinate display
            document.getElementById('mapCoords').textContent = `X: ${worldX}, Z: ${worldZ}`;
        }

        function generateMapFeatures() {
            // Clear existing features
            state.mapFeatures.treasures = [];
            state.mapFeatures.discoveries = [];
            state.mapFeatures.waypoints = [];
            
            const size = state.world.size;
            
            // Generate treasures based on Collatz sequence properties
            const sequence = state.sequence;
            const maxValue = state.maxValue;
            
            let treasuresPlaced = 0;
            for (let i = 0; i < sequence.length && treasuresPlaced < 5; i++) {
                const value = sequence[i];
                
                // Place treasures at mathematically interesting locations
                if (value > maxValue * 0.8 || value === Math.max(...sequence.slice(0, i + 1))) {
                    const x = Math.floor((i * 3.7) % size); // Use golden ratio-ish for distribution
                    const z = Math.floor((i * 2.3) % size);
                    
                    if (state.world.terrainData && state.world.terrainData[z] && state.world.terrainData[z][x]) {
                        const elevation = state.world.terrainData[z][x];
                        if (elevation > 0.4) { // Only place on solid ground
                            state.mapFeatures.treasures.push({
                                x, z, 
                                value, 
                                found: false,
                                type: 'collatz',
                                description: `Collatz Peak: ${value}`
                            });
                            treasuresPlaced++;
                        }
                    }
                }
            }
            
            // Generate discoveries at special mathematical locations
            const discoveries = [
                {
                    name: "Sequence Start",
                    description: "Where the Collatz journey begins",
                    condition: (x, z) => {
                        const centerX = Math.floor(size / 2);
                        const centerZ = Math.floor(size / 2);
                        return Math.abs(x - centerX) < 3 && Math.abs(z - centerZ) < 3;
                    }
                },
                {
                    name: "Golden Spiral",
                    description: "Mathematical beauty in terrain",
                    condition: (x, z) => {
                        const phi = 1.618033988749;
                        return Math.abs((x + z) % Math.floor(phi * 10)) < 2;
                    }
                },
                {
                    name: "Fibonacci Echo",
                    description: "Numbers within numbers",
                    condition: (x, z) => {
                        const fib = [1, 1, 2, 3, 5, 8, 13, 21, 34];
                        return fib.includes((x + z) % 35);
                    }
                }
            ];
            
            discoveries.forEach((disc, index) => {
                for (let attempts = 0; attempts < 50; attempts++) {
                    const x = Math.floor(Math.random() * size);
                    const z = Math.floor(Math.random() * size);
                    
                    if (disc.condition(x, z) && state.world.terrainData[z] && state.world.terrainData[z][x]) {
                        state.mapFeatures.discoveries.push({
                            x, z,
                            name: disc.name,
                            description: disc.description,
                            found: false
                        });
                        break;
                    }
                }
            });
            
            console.log(`🎯 Generated ${treasuresPlaced} treasures and ${state.mapFeatures.discoveries.length} discoveries`);
        }

        function checkNearbyFeatures() {
            const playerX = Math.floor(state.player.position.x);
            const playerZ = Math.floor(state.player.position.z);
            const detectionRadius = 3;
            
            // Check treasures
            state.mapFeatures.treasures.forEach(treasure => {
                if (!treasure.found) {
                    const distance = Math.sqrt(
                        Math.pow(playerX - treasure.x, 2) + 
                        Math.pow(playerZ - treasure.z, 2)
                    );
                    
                    if (distance <= detectionRadius) {
                        treasure.found = true;
                        state.achievements.treasuresFound++;
                        showDiscoveryNotification(`🏆 Treasure Found!`, treasure.description);
                        updateMapCounters();
                    }
                }
            });
            
            // Check discoveries
            state.mapFeatures.discoveries.forEach(discovery => {
                if (!discovery.found) {
                    const distance = Math.sqrt(
                        Math.pow(playerX - discovery.x, 2) + 
                        Math.pow(playerZ - discovery.z, 2)
                    );
                    
                    if (distance <= detectionRadius) {
                        discovery.found = true;
                        state.achievements.discoveries.add(discovery.name);
                        showDiscoveryNotification(`🔍 Discovery!`, `${discovery.name}: ${discovery.description}`);
                        updateMapCounters();
                    }
                }
            });
        }

        function showDiscoveryNotification(title, message) {
            // Create temporary notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, var(--primary), var(--secondary));
                color: white;
                padding: 20px 30px;
                border-radius: 15px;
                font-size: 1.1em;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                border: 2px solid var(--accent);
                animation: discoveryPop 3s ease-out forwards;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 1.3em; margin-bottom: 8px;">${title}</div>
                <div style="font-size: 0.9em; opacity: 0.9;">${message}</div>
            `;
            
            // Add animation CSS
            const style = document.createElement('style');
            style.textContent = `
                @keyframes discoveryPop {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    30% { transform: translate(-50%, -50%) scale(1); }
                    70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(notification);
            
            // Remove after animation
            setTimeout(() => {
                document.body.removeChild(notification);
                document.head.removeChild(style);
            }, 3000);
        }

        function updateMapCounters() {
            document.getElementById('treasureCount').textContent = state.achievements.treasuresFound;
            document.getElementById('waypointCount').textContent = state.achievements.waypointsPlaced;
            document.getElementById('discoveryCount').textContent = state.achievements.discoveries.size;
        }

        function clearWaypoints() {
            state.mapFeatures.waypoints = [];
            state.mapFeatures.selectedWaypoint = null;
            renderMap();
        }

        function teleportToWaypoint() {
            if (state.mapFeatures.selectedWaypoint) {
                const waypoint = state.mapFeatures.selectedWaypoint;
                let height = 30; // Default height
                
                // Get terrain height at waypoint
                if (state.world.terrainData && 
                    waypoint.z < state.world.terrainData.length && 
                    waypoint.x < state.world.terrainData[waypoint.z].length) {
                    const elevation = state.world.terrainData[waypoint.z][waypoint.x];
                    height = Math.floor(elevation * state.world.maxHeight) + 5;
                }
                
                state.player.position.set(waypoint.x, height, waypoint.z);
                state.player.velocity.set(0, 0, 0);
                
                // Close map and show game
                toggleMap();
                
                console.log(`🚀 Teleported to waypoint (${waypoint.x}, ${waypoint.z})`);
            }
        }

        function updateMapLegend() {
            const container = document.getElementById('mapLegend');
            container.innerHTML = '';
            
            const pack = TEXTURE_PACKS[state.currentTexturePack];
            Object.entries(pack.materials).forEach(([materialType, materialData]) => {
                const legendItem = document.createElement('div');
                legendItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    padding: 5px;
                    border-radius: 5px;
                    font-size: 0.85em;
                `;
                
                // Convert hex color to RGB
                const hexColor = materialData.color || 0x888888;
                const rgbColor = [
                    (hexColor >> 16) & 255,
                    (hexColor >> 8) & 255,
                    hexColor & 255
                ];
                
                legendItem.innerHTML = `
                    <div style="width: 16px; height: 16px; border-radius: 3px; border: 1px solid rgba(255, 255, 255, 0.2); background: rgb(${rgbColor.join(',')});"></div>
                    <span>${materialType.charAt(0).toUpperCase() + materialType.slice(1)}</span>
                `;
                container.appendChild(legendItem);
            });
        }

        function updatePlayerMapInfo() {
            if (!state.world.terrainData) return;
            
            const pos = state.player.position;
            const x = Math.floor(pos.x);
            const z = Math.floor(pos.z);
            const y = Math.floor(pos.y);
            
            // Update position
            document.getElementById('playerPosition').textContent = `X: ${x}, Z: ${z}`;
            document.getElementById('playerElevation').textContent = `Y: ${y}`;
            
            // Determine biome based on current material type
            if (x >= 0 && x < state.world.size && z >= 0 && z < state.world.size) {
                const elevation = state.world.terrainData[z][x];
                const materialType = getMaterialTypeForElevation(elevation);
                const biome = materialType.charAt(0).toUpperCase() + materialType.slice(1);
                
                document.getElementById('playerBiome').textContent = biome;
            }
        }

        // ============ INITIALIZATION ============
        function init() {
            try {
                initThreeJS();
                initControls();
                initUI();
                generateTerrain();
                
                document.body.style.cursor = 'default';
                
                requestAnimationFrame(gameLoop);
                
                console.log('🎮 Enhanced Collatz Voxel Terrain initialized!');
            } catch (error) {
                console.error('Failed to initialize game:', error);
            }
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>